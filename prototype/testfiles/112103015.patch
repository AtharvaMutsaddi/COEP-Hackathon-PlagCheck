diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
index 0000000..52fafd3
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,6 @@
+{
+    "files.associations": {
+        "defs.h": "c",
+        "traps.h": "c"
+    }
+}
\ No newline at end of file
diff --git a/Makefile b/Makefile
index 09d790c..c34c842 100644
--- a/Makefile
+++ b/Makefile
@@ -181,6 +181,7 @@ UPROGS=\
 	_usertests\
 	_wc\
 	_zombie\
+	_prischedtest\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
diff --git a/defs.h b/defs.h
index 82fb982..e203800 100644
--- a/defs.h
+++ b/defs.h
@@ -120,7 +120,9 @@ void            userinit(void);
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
-
+void            pstat(void);
+int             nice(int pid,int priority);
+int             getchosen(int pid);
 // swtch.S
 void            swtch(struct context**, struct context*);
 
diff --git a/prischedtest.c b/prischedtest.c
new file mode 100644
index 0000000..a86d169
--- /dev/null
+++ b/prischedtest.c
@@ -0,0 +1,104 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "fcntl.h"
+#define TOLERANCE 5
+#define F_LIM 1000000000 
+#define NUM_PROC 5
+void f() {
+   for(int i=0;i<F_LIM;i++){
+    ;
+   }
+}
+
+int
+throughput(int pri)
+{
+    int start = uptime();
+    for (int i = 0; i < NUM_PROC; i++) {
+        int pid = fork();
+        if (pid < 0) {
+            printf(1, "fork failed\n");
+            exit();
+        }
+        else if (pid == 0) {
+            nice(pid,pri);
+            f();
+            exit();
+        }
+    }
+
+    for (int i = 0; i < 5; i++) {
+        wait();
+    }
+    int end = uptime();
+    int time = (end - start);
+    int thru = (NUM_PROC*10)/time;
+    return thru;
+}
+void prischedtest()
+{
+  printf(1, "priority scheduling working...\n");
+  int pid1=-1,pid2=-1;
+  pid1 = fork();
+  if (pid1 < 0)
+  {
+    printf(1, "fork failed!\n");
+    exit();
+  }
+  else if (pid1 == 0)
+  {
+    nice(getpid(), 2);
+    while (1)
+    {
+      ;
+    }
+    exit();
+  }
+  else
+  {
+    pid2 = fork();
+    if (pid2 < 0)
+    {
+      printf(1, "fork failed!\n");
+      exit();
+    }
+    else if (pid2 == 0)
+    {
+      nice(getpid(), 4);
+      while(1)
+      {
+        ;
+      }
+      exit();
+    }
+    else
+    {
+      sleep(800);
+      int c1, c2;
+      c1 = getchosen(pid1);
+      c2 = getchosen(pid2);
+      int diff = c2 - (c1 * 2);
+      if (diff < 0)
+      {
+        diff *= (-1);
+      }
+      if (diff <= TOLERANCE)
+      {
+        printf(1, "ok\n");
+      }
+      else
+      {
+        printf(2, "failed\n");
+      }
+    }
+  }
+  return;
+}
+int main()
+{;
+  prischedtest();
+  printf(1,"Throughput via priority scheduling is: %d process/sec\n",throughput(4));
+  printf(1,"Throughput via round robin scheduling is: %d process/sec\n",throughput(1));
+  exit();
+}
\ No newline at end of file
diff --git a/proc.c b/proc.c
index 806b1b1..e3fe011 100644
--- a/proc.c
+++ b/proc.c
@@ -7,7 +7,8 @@
 #include "proc.h"
 #include "spinlock.h"
 
-struct {
+struct
+{
   struct spinlock lock;
   struct proc proc[NPROC];
 } ptable;
@@ -20,32 +21,85 @@ extern void trapret(void);
 
 static void wakeup1(void *chan);
 
-void
-pinit(void)
+int getchosen(int pid)
+{
+  struct proc *p;
+  acquire(&ptable.lock);
+  int chosen=1;
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  {
+    if (p->pid == pid)
+    {
+      chosen=p->chosen;
+      break;
+    }
+  }
+  release(&ptable.lock);
+  return chosen;
+}
+void pstat()
+{
+  sti();
+  char *proc_states[6] = {"UNUSED", "EMBRYO", "SLEEPING", "RUNNABLE", "RUNNING", "ZOMBIE"};
+  struct proc *p;
+  acquire(&ptable.lock);
+  cprintf("name\tpid\tpriority\tstate\tnum times sched\n");
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  {
+    if (p->state != UNUSED)
+    {
+      cprintf("%s\t%d\t%d\t%s\t%d\n", p->name, p->pid, p->priority, proc_states[p->state], p->chosen);
+    }
+  }
+  release(&ptable.lock);
+}
+int nice(int pid, int priority)
+{
+  struct proc *p;
+  acquire(&ptable.lock);
+  int pri_set = 0;
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  {
+    if (p->pid == pid)
+    {
+      p->priority = priority;
+      pri_set = 1;
+      break;
+    }
+  }
+  release(&ptable.lock);
+  if (pri_set == 1)
+  {
+    return pid;
+  }
+  return -1;
+}
+void pinit(void)
 {
   initlock(&ptable.lock, "ptable");
 }
 
 // Must be called with interrupts disabled
-int
-cpuid() {
-  return mycpu()-cpus;
+int cpuid()
+{
+  return mycpu() - cpus;
 }
 
 // Must be called with interrupts disabled to avoid the caller being
 // rescheduled between reading lapicid and running through the loop.
-struct cpu*
+struct cpu *
 mycpu(void)
 {
   int apicid, i;
-  
-  if(readeflags()&FL_IF)
+
+  if (readeflags() & FL_IF)
     panic("mycpu called with interrupts enabled\n");
-  
+
   apicid = lapicid();
   // APIC IDs are not guaranteed to be contiguous. Maybe we should have
   // a reverse map, or reserve a register to store &cpus[i].
-  for (i = 0; i < ncpu; ++i) {
+  for (i = 0; i < ncpu; ++i)
+  {
     if (cpus[i].apicid == apicid)
       return &cpus[i];
   }
@@ -54,8 +108,9 @@ mycpu(void)
 
 // Disable interrupts so that we are not rescheduled
 // while reading proc from the cpu structure
-struct proc*
-myproc(void) {
+struct proc *
+myproc(void)
+{
   struct cpu *c;
   struct proc *p;
   pushcli();
@@ -65,12 +120,12 @@ myproc(void) {
   return p;
 }
 
-//PAGEBREAK: 32
-// Look in the process table for an UNUSED proc.
-// If found, change state to EMBRYO and initialize
-// state required to run in the kernel.
-// Otherwise return 0.
-static struct proc*
+// PAGEBREAK: 32
+//  Look in the process table for an UNUSED proc.
+//  If found, change state to EMBRYO and initialize
+//  state required to run in the kernel.
+//  Otherwise return 0.
+static struct proc *
 allocproc(void)
 {
   struct proc *p;
@@ -78,8 +133,8 @@ allocproc(void)
 
   acquire(&ptable.lock);
 
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == UNUSED)
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    if (p->state == UNUSED)
       goto found;
 
   release(&ptable.lock);
@@ -88,11 +143,13 @@ allocproc(void)
 found:
   p->state = EMBRYO;
   p->pid = nextpid++;
-
+  p->priority = 1;
+  p->chosen = 0;
   release(&ptable.lock);
 
   // Allocate kernel stack.
-  if((p->kstack = kalloc()) == 0){
+  if ((p->kstack = kalloc()) == 0)
+  {
     p->state = UNUSED;
     return 0;
   }
@@ -100,33 +157,32 @@ found:
 
   // Leave room for trap frame.
   sp -= sizeof *p->tf;
-  p->tf = (struct trapframe*)sp;
+  p->tf = (struct trapframe *)sp;
 
   // Set up new context to start executing at forkret,
   // which returns to trapret.
   sp -= 4;
-  *(uint*)sp = (uint)trapret;
+  *(uint *)sp = (uint)trapret;
 
   sp -= sizeof *p->context;
-  p->context = (struct context*)sp;
+  p->context = (struct context *)sp;
   memset(p->context, 0, sizeof *p->context);
   p->context->eip = (uint)forkret;
 
   return p;
 }
 
-//PAGEBREAK: 32
-// Set up first user process.
-void
-userinit(void)
+// PAGEBREAK: 32
+//  Set up first user process.
+void userinit(void)
 {
   struct proc *p;
   extern char _binary_initcode_start[], _binary_initcode_size[];
 
   p = allocproc();
-  
+
   initproc = p;
-  if((p->pgdir = setupkvm()) == 0)
+  if ((p->pgdir = setupkvm()) == 0)
     panic("userinit: out of memory?");
   inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
   p->sz = PGSIZE;
@@ -137,7 +193,7 @@ userinit(void)
   p->tf->ss = p->tf->ds;
   p->tf->eflags = FL_IF;
   p->tf->esp = PGSIZE;
-  p->tf->eip = 0;  // beginning of initcode.S
+  p->tf->eip = 0; // beginning of initcode.S
 
   safestrcpy(p->name, "initcode", sizeof(p->name));
   p->cwd = namei("/");
@@ -155,18 +211,20 @@ userinit(void)
 
 // Grow current process's memory by n bytes.
 // Return 0 on success, -1 on failure.
-int
-growproc(int n)
+int growproc(int n)
 {
   uint sz;
   struct proc *curproc = myproc();
 
   sz = curproc->sz;
-  if(n > 0){
-    if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
+  if (n > 0)
+  {
+    if ((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
       return -1;
-  } else if(n < 0){
-    if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
+  }
+  else if (n < 0)
+  {
+    if ((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
       return -1;
   }
   curproc->sz = sz;
@@ -177,20 +235,21 @@ growproc(int n)
 // Create a new process copying p as the parent.
 // Sets up stack to return as if from system call.
 // Caller must set state of returned proc to RUNNABLE.
-int
-fork(void)
+int fork(void)
 {
   int i, pid;
   struct proc *np;
   struct proc *curproc = myproc();
 
   // Allocate process.
-  if((np = allocproc()) == 0){
+  if ((np = allocproc()) == 0)
+  {
     return -1;
   }
 
   // Copy process state from proc.
-  if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
+  if ((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0)
+  {
     kfree(np->kstack);
     np->kstack = 0;
     np->state = UNUSED;
@@ -203,8 +262,8 @@ fork(void)
   // Clear %eax so that fork returns 0 in the child.
   np->tf->eax = 0;
 
-  for(i = 0; i < NOFILE; i++)
-    if(curproc->ofile[i])
+  for (i = 0; i < NOFILE; i++)
+    if (curproc->ofile[i])
       np->ofile[i] = filedup(curproc->ofile[i]);
   np->cwd = idup(curproc->cwd);
 
@@ -224,19 +283,20 @@ fork(void)
 // Exit the current process.  Does not return.
 // An exited process remains in the zombie state
 // until its parent calls wait() to find out it exited.
-void
-exit(void)
+void exit(void)
 {
   struct proc *curproc = myproc();
   struct proc *p;
   int fd;
 
-  if(curproc == initproc)
+  if (curproc == initproc)
     panic("init exiting");
 
   // Close all open files.
-  for(fd = 0; fd < NOFILE; fd++){
-    if(curproc->ofile[fd]){
+  for (fd = 0; fd < NOFILE; fd++)
+  {
+    if (curproc->ofile[fd])
+    {
       fileclose(curproc->ofile[fd]);
       curproc->ofile[fd] = 0;
     }
@@ -253,10 +313,12 @@ exit(void)
   wakeup1(curproc->parent);
 
   // Pass abandoned children to init.
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->parent == curproc){
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  {
+    if (p->parent == curproc)
+    {
       p->parent = initproc;
-      if(p->state == ZOMBIE)
+      if (p->state == ZOMBIE)
         wakeup1(initproc);
     }
   }
@@ -269,22 +331,24 @@ exit(void)
 
 // Wait for a child process to exit and return its pid.
 // Return -1 if this process has no children.
-int
-wait(void)
+int wait(void)
 {
   struct proc *p;
   int havekids, pid;
   struct proc *curproc = myproc();
-  
+
   acquire(&ptable.lock);
-  for(;;){
+  for (;;)
+  {
     // Scan through table looking for exited children.
     havekids = 0;
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->parent != curproc)
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    {
+      if (p->parent != curproc)
         continue;
       havekids = 1;
-      if(p->state == ZOMBIE){
+      if (p->state == ZOMBIE)
+      {
         // Found one.
         pid = p->pid;
         kfree(p->kstack);
@@ -301,57 +365,57 @@ wait(void)
     }
 
     // No point waiting if we don't have any children.
-    if(!havekids || curproc->killed){
+    if (!havekids || curproc->killed)
+    {
       release(&ptable.lock);
       return -1;
     }
 
     // Wait for children to exit.  (See wakeup1 call in proc_exit.)
-    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+    sleep(curproc, &ptable.lock); // DOC: wait-sleep
   }
 }
 
-//PAGEBREAK: 42
-// Per-CPU process scheduler.
-// Each CPU calls scheduler() after setting itself up.
-// Scheduler never returns.  It loops, doing:
-//  - choose a process to run
-//  - swtch to start running that process
-//  - eventually that process transfers control
-//      via swtch back to the scheduler.
-void
-scheduler(void)
+// PAGEBREAK: 42
+//  Per-CPU process scheduler.
+//  Each CPU calls scheduler() after setting itself up.
+//  Scheduler never returns.  It loops, doing:
+//   - choose a process to run
+//   - swtch to start running that process
+//   - eventually that process transfers control
+//       via swtch back to the scheduler.
+void scheduler(void)
 {
   struct proc *p;
   struct cpu *c = mycpu();
   c->proc = 0;
-  
-  for(;;){
+  for (;;)
+  {
     // Enable interrupts on this processor.
     sti();
 
     // Loop over process table looking for process to run.
     acquire(&ptable.lock);
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->state != RUNNABLE)
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    {
+      if (p->state != RUNNABLE)
         continue;
-
-      // Switch to chosen process.  It is the process's job
-      // to release ptable.lock and then reacquire it
-      // before jumping back to us.
-      c->proc = p;
-      switchuvm(p);
-      p->state = RUNNING;
-
-      swtch(&(c->scheduler), p->context);
-      switchkvm();
-
+      for (int i = 0; i < p->priority; i++)
+      {
+
+        c->proc = p;
+        switchuvm(p);
+        p->state = RUNNING;
+        p->chosen++;
+        swtch(&(c->scheduler), p->context);
+        switchkvm();
+      }
       // Process is done running for now.
       // It should have changed its p->state before coming back.
       c->proc = 0;
     }
-    release(&ptable.lock);
 
+    release(&ptable.lock);
   }
 }
 
@@ -362,19 +426,18 @@ scheduler(void)
 // be proc->intena and proc->ncli, but that would
 // break in the few places where a lock is held but
 // there's no process.
-void
-sched(void)
+void sched(void)
 {
   int intena;
   struct proc *p = myproc();
 
-  if(!holding(&ptable.lock))
+  if (!holding(&ptable.lock))
     panic("sched ptable.lock");
-  if(mycpu()->ncli != 1)
+  if (mycpu()->ncli != 1)
     panic("sched locks");
-  if(p->state == RUNNING)
+  if (p->state == RUNNING)
     panic("sched running");
-  if(readeflags()&FL_IF)
+  if (readeflags() & FL_IF)
     panic("sched interruptible");
   intena = mycpu()->intena;
   swtch(&p->context, mycpu()->scheduler);
@@ -382,10 +445,9 @@ sched(void)
 }
 
 // Give up the CPU for one scheduling round.
-void
-yield(void)
+void yield(void)
 {
-  acquire(&ptable.lock);  //DOC: yieldlock
+  acquire(&ptable.lock); // DOC: yieldlock
   myproc()->state = RUNNABLE;
   sched();
   release(&ptable.lock);
@@ -393,14 +455,14 @@ yield(void)
 
 // A fork child's very first scheduling by scheduler()
 // will swtch here.  "Return" to user space.
-void
-forkret(void)
+void forkret(void)
 {
   static int first = 1;
   // Still holding ptable.lock from scheduler.
   release(&ptable.lock);
 
-  if (first) {
+  if (first)
+  {
     // Some initialization functions must be run in the context
     // of a regular process (e.g., they call sleep), and thus cannot
     // be run from main().
@@ -414,15 +476,14 @@ forkret(void)
 
 // Atomically release lock and sleep on chan.
 // Reacquires lock when awakened.
-void
-sleep(void *chan, struct spinlock *lk)
+void sleep(void *chan, struct spinlock *lk)
 {
   struct proc *p = myproc();
-  
-  if(p == 0)
+
+  if (p == 0)
     panic("sleep");
 
-  if(lk == 0)
+  if (lk == 0)
     panic("sleep without lk");
 
   // Must acquire ptable.lock in order to
@@ -431,8 +492,9 @@ sleep(void *chan, struct spinlock *lk)
   // guaranteed that we won't miss any wakeup
   // (wakeup runs with ptable.lock locked),
   // so it's okay to release lk.
-  if(lk != &ptable.lock){  //DOC: sleeplock0
-    acquire(&ptable.lock);  //DOC: sleeplock1
+  if (lk != &ptable.lock)
+  {                        // DOC: sleeplock0
+    acquire(&ptable.lock); // DOC: sleeplock1
     release(lk);
   }
   // Go to sleep.
@@ -445,28 +507,28 @@ sleep(void *chan, struct spinlock *lk)
   p->chan = 0;
 
   // Reacquire original lock.
-  if(lk != &ptable.lock){  //DOC: sleeplock2
+  if (lk != &ptable.lock)
+  { // DOC: sleeplock2
     release(&ptable.lock);
     acquire(lk);
   }
 }
 
-//PAGEBREAK!
-// Wake up all processes sleeping on chan.
-// The ptable lock must be held.
+// PAGEBREAK!
+//  Wake up all processes sleeping on chan.
+//  The ptable lock must be held.
 static void
 wakeup1(void *chan)
 {
   struct proc *p;
 
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == SLEEPING && p->chan == chan)
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    if (p->state == SLEEPING && p->chan == chan)
       p->state = RUNNABLE;
 }
 
 // Wake up all processes sleeping on chan.
-void
-wakeup(void *chan)
+void wakeup(void *chan)
 {
   acquire(&ptable.lock);
   wakeup1(chan);
@@ -476,17 +538,18 @@ wakeup(void *chan)
 // Kill the process with the given pid.
 // Process won't exit until it returns
 // to user space (see trap in trap.c).
-int
-kill(int pid)
+int kill(int pid)
 {
   struct proc *p;
 
   acquire(&ptable.lock);
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->pid == pid){
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  {
+    if (p->pid == pid)
+    {
       p->killed = 1;
       // Wake process from sleep if necessary.
-      if(p->state == SLEEPING)
+      if (p->state == SLEEPING)
         p->state = RUNNABLE;
       release(&ptable.lock);
       return 0;
@@ -496,37 +559,37 @@ kill(int pid)
   return -1;
 }
 
-//PAGEBREAK: 36
-// Print a process listing to console.  For debugging.
-// Runs when user types ^P on console.
-// No lock to avoid wedging a stuck machine further.
-void
-procdump(void)
+// PAGEBREAK: 36
+//  Print a process listing to console.  For debugging.
+//  Runs when user types ^P on console.
+//  No lock to avoid wedging a stuck machine further.
+void procdump(void)
 {
   static char *states[] = {
-  [UNUSED]    "unused",
-  [EMBRYO]    "embryo",
-  [SLEEPING]  "sleep ",
-  [RUNNABLE]  "runble",
-  [RUNNING]   "run   ",
-  [ZOMBIE]    "zombie"
-  };
+      [UNUSED] "unused",
+      [EMBRYO] "embryo",
+      [SLEEPING] "sleep ",
+      [RUNNABLE] "runble",
+      [RUNNING] "run   ",
+      [ZOMBIE] "zombie"};
   int i;
   struct proc *p;
   char *state;
   uint pc[10];
 
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->state == UNUSED)
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  {
+    if (p->state == UNUSED)
       continue;
-    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+    if (p->state >= 0 && p->state < NELEM(states) && states[p->state])
       state = states[p->state];
     else
       state = "???";
     cprintf("%d %s %s", p->pid, state, p->name);
-    if(p->state == SLEEPING){
-      getcallerpcs((uint*)p->context->ebp+2, pc);
-      for(i=0; i<10 && pc[i] != 0; i++)
+    if (p->state == SLEEPING)
+    {
+      getcallerpcs((uint *)p->context->ebp + 2, pc);
+      for (i = 0; i < 10 && pc[i] != 0; i++)
         cprintf(" %p", pc[i]);
     }
     cprintf("\n");
diff --git a/proc.h b/proc.h
index 1647114..e042412 100644
--- a/proc.h
+++ b/proc.h
@@ -49,6 +49,8 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  int priority;
+  int chosen;
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff --git a/syscall.c b/syscall.c
index ee85261..792a553 100644
--- a/syscall.c
+++ b/syscall.c
@@ -103,6 +103,9 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_pstat(void);
+extern int sys_nice(void);
+extern int sys_getchosen(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -126,6 +129,9 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_pstat]   sys_pstat,
+[SYS_nice]    sys_nice,
+[SYS_getchosen]    sys_getchosen
 };
 
 void
diff --git a/syscall.h b/syscall.h
index bc5f356..c97797b 100644
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,6 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_nice   22
+#define SYS_pstat  23
+#define SYS_getchosen  24
\ No newline at end of file
diff --git a/sysproc.c b/sysproc.c
index 0686d29..f4ebb2a 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -7,67 +7,62 @@
 #include "mmu.h"
 #include "proc.h"
 
-int
-sys_fork(void)
+int sys_fork(void)
 {
   return fork();
 }
 
-int
-sys_exit(void)
+int sys_exit(void)
 {
   exit();
-  return 0;  // not reached
+  return 0; // not reached
 }
 
-int
-sys_wait(void)
+int sys_wait(void)
 {
   return wait();
 }
 
-int
-sys_kill(void)
+int sys_kill(void)
 {
   int pid;
 
-  if(argint(0, &pid) < 0)
+  if (argint(0, &pid) < 0)
     return -1;
   return kill(pid);
 }
 
-int
-sys_getpid(void)
+int sys_getpid(void)
 {
   return myproc()->pid;
 }
 
-int
-sys_sbrk(void)
+int sys_sbrk(void)
 {
   int addr;
   int n;
 
-  if(argint(0, &n) < 0)
+  if (argint(0, &n) < 0)
     return -1;
   addr = myproc()->sz;
-  if(growproc(n) < 0)
+  if (growproc(n) < 0)
     return -1;
   return addr;
 }
 
-int
-sys_sleep(void)
+int sys_sleep(void)
 {
   int n;
   uint ticks0;
 
-  if(argint(0, &n) < 0)
+  if (argint(0, &n) < 0)
     return -1;
   acquire(&tickslock);
   ticks0 = ticks;
-  while(ticks - ticks0 < n){
-    if(myproc()->killed){
+  while (ticks - ticks0 < n)
+  {
+    if (myproc()->killed)
+    {
       release(&tickslock);
       return -1;
     }
@@ -79,8 +74,7 @@ sys_sleep(void)
 
 // return how many clock tick interrupts have occurred
 // since start.
-int
-sys_uptime(void)
+int sys_uptime(void)
 {
   uint xticks;
 
@@ -89,3 +83,29 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+int sys_pstat(void)
+{
+  pstat();
+  return 0;
+}
+
+int sys_nice(void)
+{
+  int pid, priority;
+
+  if (argint(0, &pid) < 0)
+    return -1;
+
+  if (argint(1, &priority) < 0)
+    return -1;
+
+  return nice(pid, priority);
+}
+
+int sys_getchosen(void)
+{
+  int pid;
+  if (argint(0, &pid) < 0)
+    return -1;
+  return getchosen(pid);
+}
\ No newline at end of file
diff --git a/user.h b/user.h
index 4f99c52..d4aa241 100644
--- a/user.h
+++ b/user.h
@@ -37,3 +37,8 @@ void* memset(void*, int, uint);
 void* malloc(uint);
 void free(void*);
 int atoi(const char*);
+
+// proc.c
+void            pstat(void);
+int             nice(int pid,int priority);
+int             getchosen(int pid);
\ No newline at end of file
diff --git a/usertests.c b/usertests.c
index a1e97e7..60493b7 100644
--- a/usertests.c
+++ b/usertests.c
@@ -10,28 +10,31 @@
 
 char buf[8192];
 char name[3];
-char *echoargv[] = { "echo", "ALL", "TESTS", "PASSED", 0 };
+char *echoargv[] = {"echo", "ALL", "TESTS", "PASSED", 0};
 int stdout = 1;
 
 // does chdir() call iput(p->cwd) in a transaction?
-void
-iputtest(void)
+void iputtest(void)
 {
   printf(stdout, "iput test\n");
 
-  if(mkdir("iputdir") < 0){
+  if (mkdir("iputdir") < 0)
+  {
     printf(stdout, "mkdir failed\n");
     exit();
   }
-  if(chdir("iputdir") < 0){
+  if (chdir("iputdir") < 0)
+  {
     printf(stdout, "chdir iputdir failed\n");
     exit();
   }
-  if(unlink("../iputdir") < 0){
+  if (unlink("../iputdir") < 0)
+  {
     printf(stdout, "unlink ../iputdir failed\n");
     exit();
   }
-  if(chdir("/") < 0){
+  if (chdir("/") < 0)
+  {
     printf(stdout, "chdir / failed\n");
     exit();
   }
@@ -39,28 +42,32 @@ iputtest(void)
 }
 
 // does exit() call iput(p->cwd) in a transaction?
-void
-exitiputtest(void)
+void exitiputtest(void)
 {
   int pid;
 
   printf(stdout, "exitiput test\n");
 
   pid = fork();
-  if(pid < 0){
+  if (pid < 0)
+  {
     printf(stdout, "fork failed\n");
     exit();
   }
-  if(pid == 0){
-    if(mkdir("iputdir") < 0){
+  if (pid == 0)
+  {
+    if (mkdir("iputdir") < 0)
+    {
       printf(stdout, "mkdir failed\n");
       exit();
     }
-    if(chdir("iputdir") < 0){
+    if (chdir("iputdir") < 0)
+    {
       printf(stdout, "child chdir failed\n");
       exit();
     }
-    if(unlink("../iputdir") < 0){
+    if (unlink("../iputdir") < 0)
+    {
       printf(stdout, "unlink ../iputdir failed\n");
       exit();
     }
@@ -81,31 +88,35 @@ exitiputtest(void)
 //      for(i = 0; i < 10000; i++)
 //        yield();
 //    }
-void
-openiputtest(void)
+void openiputtest(void)
 {
   int pid;
 
   printf(stdout, "openiput test\n");
-  if(mkdir("oidir") < 0){
+  if (mkdir("oidir") < 0)
+  {
     printf(stdout, "mkdir oidir failed\n");
     exit();
   }
   pid = fork();
-  if(pid < 0){
+  if (pid < 0)
+  {
     printf(stdout, "fork failed\n");
     exit();
   }
-  if(pid == 0){
+  if (pid == 0)
+  {
     int fd = open("oidir", O_RDWR);
-    if(fd >= 0){
+    if (fd >= 0)
+    {
       printf(stdout, "open directory for write succeeded\n");
       exit();
     }
     exit();
   }
   sleep(1);
-  if(unlink("oidir") != 0){
+  if (unlink("oidir") != 0)
+  {
     printf(stdout, "unlink failed\n");
     exit();
   }
@@ -115,46 +126,52 @@ openiputtest(void)
 
 // simple file system tests
 
-void
-opentest(void)
+void opentest(void)
 {
   int fd;
 
   printf(stdout, "open test\n");
   fd = open("echo", 0);
-  if(fd < 0){
+  if (fd < 0)
+  {
     printf(stdout, "open echo failed!\n");
     exit();
   }
   close(fd);
   fd = open("doesnotexist", 0);
-  if(fd >= 0){
+  if (fd >= 0)
+  {
     printf(stdout, "open doesnotexist succeeded!\n");
     exit();
   }
   printf(stdout, "open test ok\n");
 }
 
-void
-writetest(void)
+void writetest(void)
 {
   int fd;
   int i;
 
   printf(stdout, "small file test\n");
-  fd = open("small", O_CREATE|O_RDWR);
-  if(fd >= 0){
+  fd = open("small", O_CREATE | O_RDWR);
+  if (fd >= 0)
+  {
     printf(stdout, "creat small succeeded; ok\n");
-  } else {
+  }
+  else
+  {
     printf(stdout, "error: creat small failed!\n");
     exit();
   }
-  for(i = 0; i < 100; i++){
-    if(write(fd, "aaaaaaaaaa", 10) != 10){
+  for (i = 0; i < 100; i++)
+  {
+    if (write(fd, "aaaaaaaaaa", 10) != 10)
+    {
       printf(stdout, "error: write aa %d new file failed\n", i);
       exit();
     }
-    if(write(fd, "bbbbbbbbbb", 10) != 10){
+    if (write(fd, "bbbbbbbbbb", 10) != 10)
+    {
       printf(stdout, "error: write bb %d new file failed\n", i);
       exit();
     }
@@ -162,44 +179,53 @@ writetest(void)
   printf(stdout, "writes ok\n");
   close(fd);
   fd = open("small", O_RDONLY);
-  if(fd >= 0){
+  if (fd >= 0)
+  {
     printf(stdout, "open small succeeded ok\n");
-  } else {
+  }
+  else
+  {
     printf(stdout, "error: open small failed!\n");
     exit();
   }
   i = read(fd, buf, 2000);
-  if(i == 2000){
+  if (i == 2000)
+  {
     printf(stdout, "read succeeded ok\n");
-  } else {
+  }
+  else
+  {
     printf(stdout, "read failed\n");
     exit();
   }
   close(fd);
 
-  if(unlink("small") < 0){
+  if (unlink("small") < 0)
+  {
     printf(stdout, "unlink small failed\n");
     exit();
   }
   printf(stdout, "small file test ok\n");
 }
 
-void
-writetest1(void)
+void writetest1(void)
 {
   int i, fd, n;
 
   printf(stdout, "big files test\n");
 
-  fd = open("big", O_CREATE|O_RDWR);
-  if(fd < 0){
+  fd = open("big", O_CREATE | O_RDWR);
+  if (fd < 0)
+  {
     printf(stdout, "error: creat big failed!\n");
     exit();
   }
 
-  for(i = 0; i < MAXFILE; i++){
-    ((int*)buf)[0] = i;
-    if(write(fd, buf, 512) != 512){
+  for (i = 0; i < MAXFILE; i++)
+  {
+    ((int *)buf)[0] = i;
+    if (write(fd, buf, 512) != 512)
+    {
       printf(stdout, "error: write big file failed\n", i);
       exit();
     }
@@ -208,41 +234,48 @@ writetest1(void)
   close(fd);
 
   fd = open("big", O_RDONLY);
-  if(fd < 0){
+  if (fd < 0)
+  {
     printf(stdout, "error: open big failed!\n");
     exit();
   }
 
   n = 0;
-  for(;;){
+  for (;;)
+  {
     i = read(fd, buf, 512);
-    if(i == 0){
-      if(n == MAXFILE - 1){
+    if (i == 0)
+    {
+      if (n == MAXFILE - 1)
+      {
         printf(stdout, "read only %d blocks from big", n);
         exit();
       }
       break;
-    } else if(i != 512){
+    }
+    else if (i != 512)
+    {
       printf(stdout, "read failed %d\n", i);
       exit();
     }
-    if(((int*)buf)[0] != n){
+    if (((int *)buf)[0] != n)
+    {
       printf(stdout, "read content of block %d is %d\n",
-             n, ((int*)buf)[0]);
+             n, ((int *)buf)[0]);
       exit();
     }
     n++;
   }
   close(fd);
-  if(unlink("big") < 0){
+  if (unlink("big") < 0)
+  {
     printf(stdout, "unlink big failed\n");
     exit();
   }
   printf(stdout, "big files ok\n");
 }
 
-void
-createtest(void)
+void createtest(void)
 {
   int i, fd;
 
@@ -250,14 +283,16 @@ createtest(void)
 
   name[0] = 'a';
   name[2] = '\0';
-  for(i = 0; i < 52; i++){
+  for (i = 0; i < 52; i++)
+  {
     name[1] = '0' + i;
-    fd = open(name, O_CREATE|O_RDWR);
+    fd = open(name, O_CREATE | O_RDWR);
     close(fd);
   }
   name[0] = 'a';
   name[2] = '\0';
-  for(i = 0; i < 52; i++){
+  for (i = 0; i < 52; i++)
+  {
     name[1] = '0' + i;
     unlink(name);
   }
@@ -268,33 +303,37 @@ void dirtest(void)
 {
   printf(stdout, "mkdir test\n");
 
-  if(mkdir("dir0") < 0){
+  if (mkdir("dir0") < 0)
+  {
     printf(stdout, "mkdir failed\n");
     exit();
   }
 
-  if(chdir("dir0") < 0){
+  if (chdir("dir0") < 0)
+  {
     printf(stdout, "chdir dir0 failed\n");
     exit();
   }
 
-  if(chdir("..") < 0){
+  if (chdir("..") < 0)
+  {
     printf(stdout, "chdir .. failed\n");
     exit();
   }
 
-  if(unlink("dir0") < 0){
+  if (unlink("dir0") < 0)
+  {
     printf(stdout, "unlink dir0 failed\n");
     exit();
   }
   printf(stdout, "mkdir test ok\n");
 }
 
-void
-exectest(void)
+void exectest(void)
 {
   printf(stdout, "exec test\n");
-  if(exec("echo", echoargv) < 0){
+  if (exec("echo", echoargv) < 0)
+  {
     printf(stdout, "exec echo failed\n");
     exit();
   }
@@ -302,52 +341,63 @@ exectest(void)
 
 // simple fork and pipe read/write
 
-void
-pipe1(void)
+void pipe1(void)
 {
   int fds[2], pid;
   int seq, i, n, cc, total;
 
-  if(pipe(fds) != 0){
+  if (pipe(fds) != 0)
+  {
     printf(1, "pipe() failed\n");
     exit();
   }
   pid = fork();
   seq = 0;
-  if(pid == 0){
+  if (pid == 0)
+  {
     close(fds[0]);
-    for(n = 0; n < 5; n++){
-      for(i = 0; i < 1033; i++)
+    for (n = 0; n < 5; n++)
+    {
+      for (i = 0; i < 1033; i++)
         buf[i] = seq++;
-      if(write(fds[1], buf, 1033) != 1033){
+      if (write(fds[1], buf, 1033) != 1033)
+      {
         printf(1, "pipe1 oops 1\n");
         exit();
       }
     }
     exit();
-  } else if(pid > 0){
+  }
+  else if (pid > 0)
+  {
     close(fds[1]);
     total = 0;
     cc = 1;
-    while((n = read(fds[0], buf, cc)) > 0){
-      for(i = 0; i < n; i++){
-        if((buf[i] & 0xff) != (seq++ & 0xff)){
+    while ((n = read(fds[0], buf, cc)) > 0)
+    {
+      for (i = 0; i < n; i++)
+      {
+        if ((buf[i] & 0xff) != (seq++ & 0xff))
+        {
           printf(1, "pipe1 oops 2\n");
           return;
         }
       }
       total += n;
       cc = cc * 2;
-      if(cc > sizeof(buf))
+      if (cc > sizeof(buf))
         cc = sizeof(buf);
     }
-    if(total != 5 * 1033){
+    if (total != 5 * 1033)
+    {
       printf(1, "pipe1 oops 3 total %d\n", total);
       exit();
     }
     close(fds[0]);
     wait();
-  } else {
+  }
+  else
+  {
     printf(1, "fork() failed\n");
     exit();
   }
@@ -355,36 +405,37 @@ pipe1(void)
 }
 
 // meant to be run w/ at most two CPUs
-void
-preempt(void)
+void preempt(void)
 {
   int pid1, pid2, pid3;
   int pfds[2];
 
   printf(1, "preempt: ");
   pid1 = fork();
-  if(pid1 == 0)
-    for(;;)
+  if (pid1 == 0)
+    for (;;)
       ;
 
   pid2 = fork();
-  if(pid2 == 0)
-    for(;;)
+  if (pid2 == 0)
+    for (;;)
       ;
 
   pipe(pfds);
   pid3 = fork();
-  if(pid3 == 0){
+  if (pid3 == 0)
+  {
     close(pfds[0]);
-    if(write(pfds[1], "x", 1) != 1)
+    if (write(pfds[1], "x", 1) != 1)
       printf(1, "preempt write error");
     close(pfds[1]);
-    for(;;)
+    for (;;)
       ;
   }
 
   close(pfds[1]);
-  if(read(pfds[0], buf, sizeof(buf)) != 1){
+  if (read(pfds[0], buf, sizeof(buf)) != 1)
+  {
     printf(1, "preempt read error");
     return;
   }
@@ -401,50 +452,58 @@ preempt(void)
 }
 
 // try to find any races between exit and wait
-void
-exitwait(void)
+void exitwait(void)
 {
   int i, pid;
 
-  for(i = 0; i < 100; i++){
+  for (i = 0; i < 100; i++)
+  {
     pid = fork();
-    if(pid < 0){
+    if (pid < 0)
+    {
       printf(1, "fork failed\n");
       return;
     }
-    if(pid){
-      if(wait() != pid){
+    if (pid)
+    {
+      if (wait() != pid)
+      {
         printf(1, "wait wrong pid\n");
         return;
       }
-    } else {
+    }
+    else
+    {
       exit();
     }
   }
   printf(1, "exitwait ok\n");
 }
 
-void
-mem(void)
+void mem(void)
 {
   void *m1, *m2;
   int pid, ppid;
 
   printf(1, "mem test\n");
   ppid = getpid();
-  if((pid = fork()) == 0){
+  if ((pid = fork()) == 0)
+  {
     m1 = 0;
-    while((m2 = malloc(10001)) != 0){
-      *(char**)m2 = m1;
+    while ((m2 = malloc(10001)) != 0)
+    {
+      *(char **)m2 = m1;
       m1 = m2;
     }
-    while(m1){
-      m2 = *(char**)m1;
+    while (m1)
+    {
+      m2 = *(char **)m1;
       free(m1);
       m1 = m2;
     }
-    m1 = malloc(1024*20);
-    if(m1 == 0){
+    m1 = malloc(1024 * 20);
+    if (m1 == 0)
+    {
       printf(1, "couldn't allocate mem?!!\n");
       kill(ppid);
       exit();
@@ -452,7 +511,9 @@ mem(void)
     free(m1);
     printf(1, "mem ok\n");
     exit();
-  } else {
+  }
+  else
+  {
     wait();
   }
 }
@@ -461,8 +522,7 @@ mem(void)
 
 // two processes write to the same file descriptor
 // is the offset shared? does inode locking work?
-void
-sharedfd(void)
+void sharedfd(void)
 {
   int fd, pid, i, n, nc, np;
   char buf[10];
@@ -470,43 +530,52 @@ sharedfd(void)
   printf(1, "sharedfd test\n");
 
   unlink("sharedfd");
-  fd = open("sharedfd", O_CREATE|O_RDWR);
-  if(fd < 0){
+  fd = open("sharedfd", O_CREATE | O_RDWR);
+  if (fd < 0)
+  {
     printf(1, "fstests: cannot open sharedfd for writing");
     return;
   }
   pid = fork();
-  memset(buf, pid==0?'c':'p', sizeof(buf));
-  for(i = 0; i < 1000; i++){
-    if(write(fd, buf, sizeof(buf)) != sizeof(buf)){
+  memset(buf, pid == 0 ? 'c' : 'p', sizeof(buf));
+  for (i = 0; i < 1000; i++)
+  {
+    if (write(fd, buf, sizeof(buf)) != sizeof(buf))
+    {
       printf(1, "fstests: write sharedfd failed\n");
       break;
     }
   }
-  if(pid == 0)
+  if (pid == 0)
     exit();
   else
     wait();
   close(fd);
   fd = open("sharedfd", 0);
-  if(fd < 0){
+  if (fd < 0)
+  {
     printf(1, "fstests: cannot open sharedfd for reading\n");
     return;
   }
   nc = np = 0;
-  while((n = read(fd, buf, sizeof(buf))) > 0){
-    for(i = 0; i < sizeof(buf); i++){
-      if(buf[i] == 'c')
+  while ((n = read(fd, buf, sizeof(buf))) > 0)
+  {
+    for (i = 0; i < sizeof(buf); i++)
+    {
+      if (buf[i] == 'c')
         nc++;
-      if(buf[i] == 'p')
+      if (buf[i] == 'p')
         np++;
     }
   }
   close(fd);
   unlink("sharedfd");
-  if(nc == 10000 && np == 10000){
+  if (nc == 10000 && np == 10000)
+  {
     printf(1, "sharedfd ok\n");
-  } else {
+  }
+  else
+  {
     printf(1, "sharedfd oops %d %d\n", nc, np);
     exit();
   }
@@ -514,35 +583,40 @@ sharedfd(void)
 
 // four processes write different files at the same
 // time, to test block allocation.
-void
-fourfiles(void)
+void fourfiles(void)
 {
   int fd, pid, i, j, n, total, pi;
-  char *names[] = { "f0", "f1", "f2", "f3" };
+  char *names[] = {"f0", "f1", "f2", "f3"};
   char *fname;
 
   printf(1, "fourfiles test\n");
 
-  for(pi = 0; pi < 4; pi++){
+  for (pi = 0; pi < 4; pi++)
+  {
     fname = names[pi];
     unlink(fname);
 
     pid = fork();
-    if(pid < 0){
+    if (pid < 0)
+    {
       printf(1, "fork failed\n");
       exit();
     }
 
-    if(pid == 0){
+    if (pid == 0)
+    {
       fd = open(fname, O_CREATE | O_RDWR);
-      if(fd < 0){
+      if (fd < 0)
+      {
         printf(1, "create failed\n");
         exit();
       }
 
-      memset(buf, '0'+pi, 512);
-      for(i = 0; i < 12; i++){
-        if((n = write(fd, buf, 500)) != 500){
+      memset(buf, '0' + pi, 512);
+      for (i = 0; i < 12; i++)
+      {
+        if ((n = write(fd, buf, 500)) != 500)
+        {
           printf(1, "write failed %d\n", n);
           exit();
         }
@@ -551,17 +625,22 @@ fourfiles(void)
     }
   }
 
-  for(pi = 0; pi < 4; pi++){
+  for (pi = 0; pi < 4; pi++)
+  {
     wait();
   }
 
-  for(i = 0; i < 2; i++){
+  for (i = 0; i < 2; i++)
+  {
     fname = names[i];
     fd = open(fname, 0);
     total = 0;
-    while((n = read(fd, buf, sizeof(buf))) > 0){
-      for(j = 0; j < n; j++){
-        if(buf[j] != '0'+i){
+    while ((n = read(fd, buf, sizeof(buf))) > 0)
+    {
+      for (j = 0; j < n; j++)
+      {
+        if (buf[j] != '0' + i)
+        {
           printf(1, "wrong char\n");
           exit();
         }
@@ -569,7 +648,8 @@ fourfiles(void)
       total += n;
     }
     close(fd);
-    if(total != 12*500){
+    if (total != 12 * 500)
+    {
       printf(1, "wrong length %d\n", total);
       exit();
     }
@@ -580,36 +660,45 @@ fourfiles(void)
 }
 
 // four processes create and delete different files in same directory
-void
-createdelete(void)
+void createdelete(void)
 {
-  enum { N = 20 };
+  enum
+  {
+    N = 20
+  };
   int pid, i, fd, pi;
   char name[32];
 
   printf(1, "createdelete test\n");
 
-  for(pi = 0; pi < 4; pi++){
+  for (pi = 0; pi < 4; pi++)
+  {
     pid = fork();
-    if(pid < 0){
+    if (pid < 0)
+    {
       printf(1, "fork failed\n");
       exit();
     }
 
-    if(pid == 0){
+    if (pid == 0)
+    {
       name[0] = 'p' + pi;
       name[2] = '\0';
-      for(i = 0; i < N; i++){
+      for (i = 0; i < N; i++)
+      {
         name[1] = '0' + i;
         fd = open(name, O_CREATE | O_RDWR);
-        if(fd < 0){
+        if (fd < 0)
+        {
           printf(1, "create failed\n");
           exit();
         }
         close(fd);
-        if(i > 0 && (i % 2 ) == 0){
+        if (i > 0 && (i % 2) == 0)
+        {
           name[1] = '0' + (i / 2);
-          if(unlink(name) < 0){
+          if (unlink(name) < 0)
+          {
             printf(1, "unlink failed\n");
             exit();
           }
@@ -619,30 +708,38 @@ createdelete(void)
     }
   }
 
-  for(pi = 0; pi < 4; pi++){
+  for (pi = 0; pi < 4; pi++)
+  {
     wait();
   }
 
   name[0] = name[1] = name[2] = 0;
-  for(i = 0; i < N; i++){
-    for(pi = 0; pi < 4; pi++){
+  for (i = 0; i < N; i++)
+  {
+    for (pi = 0; pi < 4; pi++)
+    {
       name[0] = 'p' + pi;
       name[1] = '0' + i;
       fd = open(name, 0);
-      if((i == 0 || i >= N/2) && fd < 0){
+      if ((i == 0 || i >= N / 2) && fd < 0)
+      {
         printf(1, "oops createdelete %s didn't exist\n", name);
         exit();
-      } else if((i >= 1 && i < N/2) && fd >= 0){
+      }
+      else if ((i >= 1 && i < N / 2) && fd >= 0)
+      {
         printf(1, "oops createdelete %s did exist\n", name);
         exit();
       }
-      if(fd >= 0)
+      if (fd >= 0)
         close(fd);
     }
   }
 
-  for(i = 0; i < N; i++){
-    for(pi = 0; pi < 4; pi++){
+  for (i = 0; i < N; i++)
+  {
+    for (pi = 0; pi < 4; pi++)
+    {
       name[0] = 'p' + i;
       name[1] = '0' + i;
       unlink(name);
@@ -653,14 +750,14 @@ createdelete(void)
 }
 
 // can I unlink a file and still read it?
-void
-unlinkread(void)
+void unlinkread(void)
 {
   int fd, fd1;
 
   printf(1, "unlinkread test\n");
   fd = open("unlinkread", O_CREATE | O_RDWR);
-  if(fd < 0){
+  if (fd < 0)
+  {
     printf(1, "create unlinkread failed\n");
     exit();
   }
@@ -668,11 +765,13 @@ unlinkread(void)
   close(fd);
 
   fd = open("unlinkread", O_RDWR);
-  if(fd < 0){
+  if (fd < 0)
+  {
     printf(1, "open unlinkread failed\n");
     exit();
   }
-  if(unlink("unlinkread") != 0){
+  if (unlink("unlinkread") != 0)
+  {
     printf(1, "unlink unlinkread failed\n");
     exit();
   }
@@ -681,15 +780,18 @@ unlinkread(void)
   write(fd1, "yyy", 3);
   close(fd1);
 
-  if(read(fd, buf, sizeof(buf)) != 5){
+  if (read(fd, buf, sizeof(buf)) != 5)
+  {
     printf(1, "unlinkread read failed");
     exit();
   }
-  if(buf[0] != 'h'){
+  if (buf[0] != 'h')
+  {
     printf(1, "unlinkread wrong data\n");
     exit();
   }
-  if(write(fd, buf, 10) != 10){
+  if (write(fd, buf, 10) != 10)
+  {
     printf(1, "unlinkread write failed\n");
     exit();
   }
@@ -698,8 +800,7 @@ unlinkread(void)
   printf(1, "unlinkread ok\n");
 }
 
-void
-linktest(void)
+void linktest(void)
 {
   int fd;
 
@@ -708,51 +809,60 @@ linktest(void)
   unlink("lf1");
   unlink("lf2");
 
-  fd = open("lf1", O_CREATE|O_RDWR);
-  if(fd < 0){
+  fd = open("lf1", O_CREATE | O_RDWR);
+  if (fd < 0)
+  {
     printf(1, "create lf1 failed\n");
     exit();
   }
-  if(write(fd, "hello", 5) != 5){
+  if (write(fd, "hello", 5) != 5)
+  {
     printf(1, "write lf1 failed\n");
     exit();
   }
   close(fd);
 
-  if(link("lf1", "lf2") < 0){
+  if (link("lf1", "lf2") < 0)
+  {
     printf(1, "link lf1 lf2 failed\n");
     exit();
   }
   unlink("lf1");
 
-  if(open("lf1", 0) >= 0){
+  if (open("lf1", 0) >= 0)
+  {
     printf(1, "unlinked lf1 but it is still there!\n");
     exit();
   }
 
   fd = open("lf2", 0);
-  if(fd < 0){
+  if (fd < 0)
+  {
     printf(1, "open lf2 failed\n");
     exit();
   }
-  if(read(fd, buf, sizeof(buf)) != 5){
+  if (read(fd, buf, sizeof(buf)) != 5)
+  {
     printf(1, "read lf2 failed\n");
     exit();
   }
   close(fd);
 
-  if(link("lf2", "lf2") >= 0){
+  if (link("lf2", "lf2") >= 0)
+  {
     printf(1, "link lf2 lf2 succeeded! oops\n");
     exit();
   }
 
   unlink("lf2");
-  if(link("lf2", "lf1") >= 0){
+  if (link("lf2", "lf1") >= 0)
+  {
     printf(1, "link non-existant succeeded! oops\n");
     exit();
   }
 
-  if(link(".", "lf1") >= 0){
+  if (link(".", "lf1") >= 0)
+  {
     printf(1, "link . lf1 succeeded! oops\n");
     exit();
   }
@@ -761,13 +871,13 @@ linktest(void)
 }
 
 // test concurrent create/link/unlink of the same file
-void
-concreate(void)
+void concreate(void)
 {
   char file[3];
   int i, pid, n, fd;
   char fa[40];
-  struct {
+  struct
+  {
     ushort inum;
     char name[14];
   } de;
@@ -775,23 +885,30 @@ concreate(void)
   printf(1, "concreate test\n");
   file[0] = 'C';
   file[2] = '\0';
-  for(i = 0; i < 40; i++){
+  for (i = 0; i < 40; i++)
+  {
     file[1] = '0' + i;
     unlink(file);
     pid = fork();
-    if(pid && (i % 3) == 1){
+    if (pid && (i % 3) == 1)
+    {
       link("C0", file);
-    } else if(pid == 0 && (i % 5) == 1){
+    }
+    else if (pid == 0 && (i % 5) == 1)
+    {
       link("C0", file);
-    } else {
+    }
+    else
+    {
       fd = open(file, O_CREATE | O_RDWR);
-      if(fd < 0){
+      if (fd < 0)
+      {
         printf(1, "concreate create %s failed\n", file);
         exit();
       }
       close(fd);
     }
-    if(pid == 0)
+    if (pid == 0)
       exit();
     else
       wait();
@@ -800,16 +917,20 @@ concreate(void)
   memset(fa, 0, sizeof(fa));
   fd = open(".", 0);
   n = 0;
-  while(read(fd, &de, sizeof(de)) > 0){
-    if(de.inum == 0)
+  while (read(fd, &de, sizeof(de)) > 0)
+  {
+    if (de.inum == 0)
       continue;
-    if(de.name[0] == 'C' && de.name[2] == '\0'){
+    if (de.name[0] == 'C' && de.name[2] == '\0')
+    {
       i = de.name[1] - '0';
-      if(i < 0 || i >= sizeof(fa)){
+      if (i < 0 || i >= sizeof(fa))
+      {
         printf(1, "concreate weird file %s\n", de.name);
         exit();
       }
-      if(fa[i]){
+      if (fa[i])
+      {
         printf(1, "concreate duplicate file %s\n", de.name);
         exit();
       }
@@ -819,31 +940,37 @@ concreate(void)
   }
   close(fd);
 
-  if(n != 40){
+  if (n != 40)
+  {
     printf(1, "concreate not enough files in directory listing\n");
     exit();
   }
 
-  for(i = 0; i < 40; i++){
+  for (i = 0; i < 40; i++)
+  {
     file[1] = '0' + i;
     pid = fork();
-    if(pid < 0){
+    if (pid < 0)
+    {
       printf(1, "fork failed\n");
       exit();
     }
-    if(((i % 3) == 0 && pid == 0) ||
-       ((i % 3) == 1 && pid != 0)){
+    if (((i % 3) == 0 && pid == 0) ||
+        ((i % 3) == 1 && pid != 0))
+    {
       close(open(file, 0));
       close(open(file, 0));
       close(open(file, 0));
       close(open(file, 0));
-    } else {
+    }
+    else
+    {
       unlink(file);
       unlink(file);
       unlink(file);
       unlink(file);
     }
-    if(pid == 0)
+    if (pid == 0)
       exit();
     else
       wait();
@@ -854,8 +981,7 @@ concreate(void)
 
 // another concurrent link/unlink/create test,
 // to look for deadlocks.
-void
-linkunlink()
+void linkunlink()
 {
   int pid, i;
 
@@ -863,24 +989,31 @@ linkunlink()
 
   unlink("x");
   pid = fork();
-  if(pid < 0){
+  if (pid < 0)
+  {
     printf(1, "fork failed\n");
     exit();
   }
 
   unsigned int x = (pid ? 1 : 97);
-  for(i = 0; i < 100; i++){
+  for (i = 0; i < 100; i++)
+  {
     x = x * 1103515245 + 12345;
-    if((x % 3) == 0){
+    if ((x % 3) == 0)
+    {
       close(open("x", O_RDWR | O_CREATE));
-    } else if((x % 3) == 1){
+    }
+    else if ((x % 3) == 1)
+    {
       link("cat", "x");
-    } else {
+    }
+    else
+    {
       unlink("x");
     }
   }
 
-  if(pid)
+  if (pid)
     wait();
   else
     exit();
@@ -889,8 +1022,7 @@ linkunlink()
 }
 
 // directory that uses indirect blocks
-void
-bigdir(void)
+void bigdir(void)
 {
   int i, fd;
   char name[10];
@@ -899,30 +1031,35 @@ bigdir(void)
   unlink("bd");
 
   fd = open("bd", O_CREATE);
-  if(fd < 0){
+  if (fd < 0)
+  {
     printf(1, "bigdir create failed\n");
     exit();
   }
   close(fd);
 
-  for(i = 0; i < 500; i++){
+  for (i = 0; i < 500; i++)
+  {
     name[0] = 'x';
     name[1] = '0' + (i / 64);
     name[2] = '0' + (i % 64);
     name[3] = '\0';
-    if(link("bd", name) != 0){
+    if (link("bd", name) != 0)
+    {
       printf(1, "bigdir link failed\n");
       exit();
     }
   }
 
   unlink("bd");
-  for(i = 0; i < 500; i++){
+  for (i = 0; i < 500; i++)
+  {
     name[0] = 'x';
     name[1] = '0' + (i / 64);
     name[2] = '0' + (i % 64);
     name[3] = '\0';
-    if(unlink(name) != 0){
+    if (unlink(name) != 0)
+    {
       printf(1, "bigdir unlink failed");
       exit();
     }
@@ -931,39 +1068,43 @@ bigdir(void)
   printf(1, "bigdir ok\n");
 }
 
-void
-subdir(void)
+void subdir(void)
 {
   int fd, cc;
 
   printf(1, "subdir test\n");
 
   unlink("ff");
-  if(mkdir("dd") != 0){
+  if (mkdir("dd") != 0)
+  {
     printf(1, "subdir mkdir dd failed\n");
     exit();
   }
 
   fd = open("dd/ff", O_CREATE | O_RDWR);
-  if(fd < 0){
+  if (fd < 0)
+  {
     printf(1, "create dd/ff failed\n");
     exit();
   }
   write(fd, "ff", 2);
   close(fd);
 
-  if(unlink("dd") >= 0){
+  if (unlink("dd") >= 0)
+  {
     printf(1, "unlink dd (non-empty dir) succeeded!\n");
     exit();
   }
 
-  if(mkdir("/dd/dd") != 0){
+  if (mkdir("/dd/dd") != 0)
+  {
     printf(1, "subdir mkdir dd/dd failed\n");
     exit();
   }
 
   fd = open("dd/dd/ff", O_CREATE | O_RDWR);
-  if(fd < 0){
+  if (fd < 0)
+  {
     printf(1, "create dd/dd/ff failed\n");
     exit();
   }
@@ -971,142 +1112,174 @@ subdir(void)
   close(fd);
 
   fd = open("dd/dd/../ff", 0);
-  if(fd < 0){
+  if (fd < 0)
+  {
     printf(1, "open dd/dd/../ff failed\n");
     exit();
   }
   cc = read(fd, buf, sizeof(buf));
-  if(cc != 2 || buf[0] != 'f'){
+  if (cc != 2 || buf[0] != 'f')
+  {
     printf(1, "dd/dd/../ff wrong content\n");
     exit();
   }
   close(fd);
 
-  if(link("dd/dd/ff", "dd/dd/ffff") != 0){
+  if (link("dd/dd/ff", "dd/dd/ffff") != 0)
+  {
     printf(1, "link dd/dd/ff dd/dd/ffff failed\n");
     exit();
   }
 
-  if(unlink("dd/dd/ff") != 0){
+  if (unlink("dd/dd/ff") != 0)
+  {
     printf(1, "unlink dd/dd/ff failed\n");
     exit();
   }
-  if(open("dd/dd/ff", O_RDONLY) >= 0){
+  if (open("dd/dd/ff", O_RDONLY) >= 0)
+  {
     printf(1, "open (unlinked) dd/dd/ff succeeded\n");
     exit();
   }
 
-  if(chdir("dd") != 0){
+  if (chdir("dd") != 0)
+  {
     printf(1, "chdir dd failed\n");
     exit();
   }
-  if(chdir("dd/../../dd") != 0){
+  if (chdir("dd/../../dd") != 0)
+  {
     printf(1, "chdir dd/../../dd failed\n");
     exit();
   }
-  if(chdir("dd/../../../dd") != 0){
+  if (chdir("dd/../../../dd") != 0)
+  {
     printf(1, "chdir dd/../../dd failed\n");
     exit();
   }
-  if(chdir("./..") != 0){
+  if (chdir("./..") != 0)
+  {
     printf(1, "chdir ./.. failed\n");
     exit();
   }
 
   fd = open("dd/dd/ffff", 0);
-  if(fd < 0){
+  if (fd < 0)
+  {
     printf(1, "open dd/dd/ffff failed\n");
     exit();
   }
-  if(read(fd, buf, sizeof(buf)) != 2){
+  if (read(fd, buf, sizeof(buf)) != 2)
+  {
     printf(1, "read dd/dd/ffff wrong len\n");
     exit();
   }
   close(fd);
 
-  if(open("dd/dd/ff", O_RDONLY) >= 0){
+  if (open("dd/dd/ff", O_RDONLY) >= 0)
+  {
     printf(1, "open (unlinked) dd/dd/ff succeeded!\n");
     exit();
   }
 
-  if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
+  if (open("dd/ff/ff", O_CREATE | O_RDWR) >= 0)
+  {
     printf(1, "create dd/ff/ff succeeded!\n");
     exit();
   }
-  if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
+  if (open("dd/xx/ff", O_CREATE | O_RDWR) >= 0)
+  {
     printf(1, "create dd/xx/ff succeeded!\n");
     exit();
   }
-  if(open("dd", O_CREATE) >= 0){
+  if (open("dd", O_CREATE) >= 0)
+  {
     printf(1, "create dd succeeded!\n");
     exit();
   }
-  if(open("dd", O_RDWR) >= 0){
+  if (open("dd", O_RDWR) >= 0)
+  {
     printf(1, "open dd rdwr succeeded!\n");
     exit();
   }
-  if(open("dd", O_WRONLY) >= 0){
+  if (open("dd", O_WRONLY) >= 0)
+  {
     printf(1, "open dd wronly succeeded!\n");
     exit();
   }
-  if(link("dd/ff/ff", "dd/dd/xx") == 0){
+  if (link("dd/ff/ff", "dd/dd/xx") == 0)
+  {
     printf(1, "link dd/ff/ff dd/dd/xx succeeded!\n");
     exit();
   }
-  if(link("dd/xx/ff", "dd/dd/xx") == 0){
+  if (link("dd/xx/ff", "dd/dd/xx") == 0)
+  {
     printf(1, "link dd/xx/ff dd/dd/xx succeeded!\n");
     exit();
   }
-  if(link("dd/ff", "dd/dd/ffff") == 0){
+  if (link("dd/ff", "dd/dd/ffff") == 0)
+  {
     printf(1, "link dd/ff dd/dd/ffff succeeded!\n");
     exit();
   }
-  if(mkdir("dd/ff/ff") == 0){
+  if (mkdir("dd/ff/ff") == 0)
+  {
     printf(1, "mkdir dd/ff/ff succeeded!\n");
     exit();
   }
-  if(mkdir("dd/xx/ff") == 0){
+  if (mkdir("dd/xx/ff") == 0)
+  {
     printf(1, "mkdir dd/xx/ff succeeded!\n");
     exit();
   }
-  if(mkdir("dd/dd/ffff") == 0){
+  if (mkdir("dd/dd/ffff") == 0)
+  {
     printf(1, "mkdir dd/dd/ffff succeeded!\n");
     exit();
   }
-  if(unlink("dd/xx/ff") == 0){
+  if (unlink("dd/xx/ff") == 0)
+  {
     printf(1, "unlink dd/xx/ff succeeded!\n");
     exit();
   }
-  if(unlink("dd/ff/ff") == 0){
+  if (unlink("dd/ff/ff") == 0)
+  {
     printf(1, "unlink dd/ff/ff succeeded!\n");
     exit();
   }
-  if(chdir("dd/ff") == 0){
+  if (chdir("dd/ff") == 0)
+  {
     printf(1, "chdir dd/ff succeeded!\n");
     exit();
   }
-  if(chdir("dd/xx") == 0){
+  if (chdir("dd/xx") == 0)
+  {
     printf(1, "chdir dd/xx succeeded!\n");
     exit();
   }
 
-  if(unlink("dd/dd/ffff") != 0){
+  if (unlink("dd/dd/ffff") != 0)
+  {
     printf(1, "unlink dd/dd/ff failed\n");
     exit();
   }
-  if(unlink("dd/ff") != 0){
+  if (unlink("dd/ff") != 0)
+  {
     printf(1, "unlink dd/ff failed\n");
     exit();
   }
-  if(unlink("dd") == 0){
+  if (unlink("dd") == 0)
+  {
     printf(1, "unlink non-empty dd succeeded!\n");
     exit();
   }
-  if(unlink("dd/dd") < 0){
+  if (unlink("dd/dd") < 0)
+  {
     printf(1, "unlink dd/dd failed\n");
     exit();
   }
-  if(unlink("dd") < 0){
+  if (unlink("dd") < 0)
+  {
     printf(1, "unlink dd failed\n");
     exit();
   }
@@ -1115,24 +1288,27 @@ subdir(void)
 }
 
 // test writes that are larger than the log.
-void
-bigwrite(void)
+void bigwrite(void)
 {
   int fd, sz;
 
   printf(1, "bigwrite test\n");
 
   unlink("bigwrite");
-  for(sz = 499; sz < 12*512; sz += 471){
+  for (sz = 499; sz < 12 * 512; sz += 471)
+  {
     fd = open("bigwrite", O_CREATE | O_RDWR);
-    if(fd < 0){
+    if (fd < 0)
+    {
       printf(1, "cannot create bigwrite\n");
       exit();
     }
     int i;
-    for(i = 0; i < 2; i++){
+    for (i = 0; i < 2; i++)
+    {
       int cc = write(fd, buf, sz);
-      if(cc != sz){
+      if (cc != sz)
+      {
         printf(1, "write(%d) ret %d\n", sz, cc);
         exit();
       }
@@ -1144,8 +1320,7 @@ bigwrite(void)
   printf(1, "bigwrite ok\n");
 }
 
-void
-bigfile(void)
+void bigfile(void)
 {
   int fd, i, total, cc;
 
@@ -1153,13 +1328,16 @@ bigfile(void)
 
   unlink("bigfile");
   fd = open("bigfile", O_CREATE | O_RDWR);
-  if(fd < 0){
+  if (fd < 0)
+  {
     printf(1, "cannot create bigfile");
     exit();
   }
-  for(i = 0; i < 20; i++){
+  for (i = 0; i < 20; i++)
+  {
     memset(buf, i, 600);
-    if(write(fd, buf, 600) != 600){
+    if (write(fd, buf, 600) != 600)
+    {
       printf(1, "write bigfile failed\n");
       exit();
     }
@@ -1167,31 +1345,37 @@ bigfile(void)
   close(fd);
 
   fd = open("bigfile", 0);
-  if(fd < 0){
+  if (fd < 0)
+  {
     printf(1, "cannot open bigfile\n");
     exit();
   }
   total = 0;
-  for(i = 0; ; i++){
+  for (i = 0;; i++)
+  {
     cc = read(fd, buf, 300);
-    if(cc < 0){
+    if (cc < 0)
+    {
       printf(1, "read bigfile failed\n");
       exit();
     }
-    if(cc == 0)
+    if (cc == 0)
       break;
-    if(cc != 300){
+    if (cc != 300)
+    {
       printf(1, "short read bigfile\n");
       exit();
     }
-    if(buf[0] != i/2 || buf[299] != i/2){
+    if (buf[0] != i / 2 || buf[299] != i / 2)
+    {
       printf(1, "read bigfile wrong data\n");
       exit();
     }
     total += cc;
   }
   close(fd);
-  if(total != 20*600){
+  if (total != 20 * 600)
+  {
     printf(1, "read bigfile wrong total\n");
     exit();
   }
@@ -1200,40 +1384,45 @@ bigfile(void)
   printf(1, "bigfile test ok\n");
 }
 
-void
-fourteen(void)
+void fourteen(void)
 {
   int fd;
 
   // DIRSIZ is 14.
   printf(1, "fourteen test\n");
 
-  if(mkdir("12345678901234") != 0){
+  if (mkdir("12345678901234") != 0)
+  {
     printf(1, "mkdir 12345678901234 failed\n");
     exit();
   }
-  if(mkdir("12345678901234/123456789012345") != 0){
+  if (mkdir("12345678901234/123456789012345") != 0)
+  {
     printf(1, "mkdir 12345678901234/123456789012345 failed\n");
     exit();
   }
   fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
-  if(fd < 0){
+  if (fd < 0)
+  {
     printf(1, "create 123456789012345/123456789012345/123456789012345 failed\n");
     exit();
   }
   close(fd);
   fd = open("12345678901234/12345678901234/12345678901234", 0);
-  if(fd < 0){
+  if (fd < 0)
+  {
     printf(1, "open 12345678901234/12345678901234/12345678901234 failed\n");
     exit();
   }
   close(fd);
 
-  if(mkdir("12345678901234/12345678901234") == 0){
+  if (mkdir("12345678901234/12345678901234") == 0)
+  {
     printf(1, "mkdir 12345678901234/12345678901234 succeeded!\n");
     exit();
   }
-  if(mkdir("123456789012345/12345678901234") == 0){
+  if (mkdir("123456789012345/12345678901234") == 0)
+  {
     printf(1, "mkdir 12345678901234/123456789012345 succeeded!\n");
     exit();
   }
@@ -1241,96 +1430,112 @@ fourteen(void)
   printf(1, "fourteen ok\n");
 }
 
-void
-rmdot(void)
+void rmdot(void)
 {
   printf(1, "rmdot test\n");
-  if(mkdir("dots") != 0){
+  if (mkdir("dots") != 0)
+  {
     printf(1, "mkdir dots failed\n");
     exit();
   }
-  if(chdir("dots") != 0){
+  if (chdir("dots") != 0)
+  {
     printf(1, "chdir dots failed\n");
     exit();
   }
-  if(unlink(".") == 0){
+  if (unlink(".") == 0)
+  {
     printf(1, "rm . worked!\n");
     exit();
   }
-  if(unlink("..") == 0){
+  if (unlink("..") == 0)
+  {
     printf(1, "rm .. worked!\n");
     exit();
   }
-  if(chdir("/") != 0){
+  if (chdir("/") != 0)
+  {
     printf(1, "chdir / failed\n");
     exit();
   }
-  if(unlink("dots/.") == 0){
+  if (unlink("dots/.") == 0)
+  {
     printf(1, "unlink dots/. worked!\n");
     exit();
   }
-  if(unlink("dots/..") == 0){
+  if (unlink("dots/..") == 0)
+  {
     printf(1, "unlink dots/.. worked!\n");
     exit();
   }
-  if(unlink("dots") != 0){
+  if (unlink("dots") != 0)
+  {
     printf(1, "unlink dots failed!\n");
     exit();
   }
   printf(1, "rmdot ok\n");
 }
 
-void
-dirfile(void)
+void dirfile(void)
 {
   int fd;
 
   printf(1, "dir vs file\n");
 
   fd = open("dirfile", O_CREATE);
-  if(fd < 0){
+  if (fd < 0)
+  {
     printf(1, "create dirfile failed\n");
     exit();
   }
   close(fd);
-  if(chdir("dirfile") == 0){
+  if (chdir("dirfile") == 0)
+  {
     printf(1, "chdir dirfile succeeded!\n");
     exit();
   }
   fd = open("dirfile/xx", 0);
-  if(fd >= 0){
+  if (fd >= 0)
+  {
     printf(1, "create dirfile/xx succeeded!\n");
     exit();
   }
   fd = open("dirfile/xx", O_CREATE);
-  if(fd >= 0){
+  if (fd >= 0)
+  {
     printf(1, "create dirfile/xx succeeded!\n");
     exit();
   }
-  if(mkdir("dirfile/xx") == 0){
+  if (mkdir("dirfile/xx") == 0)
+  {
     printf(1, "mkdir dirfile/xx succeeded!\n");
     exit();
   }
-  if(unlink("dirfile/xx") == 0){
+  if (unlink("dirfile/xx") == 0)
+  {
     printf(1, "unlink dirfile/xx succeeded!\n");
     exit();
   }
-  if(link("README", "dirfile/xx") == 0){
+  if (link("README", "dirfile/xx") == 0)
+  {
     printf(1, "link to dirfile/xx succeeded!\n");
     exit();
   }
-  if(unlink("dirfile") != 0){
+  if (unlink("dirfile") != 0)
+  {
     printf(1, "unlink dirfile failed!\n");
     exit();
   }
 
   fd = open(".", O_RDWR);
-  if(fd >= 0){
+  if (fd >= 0)
+  {
     printf(1, "open . for writing succeeded!\n");
     exit();
   }
   fd = open(".", 0);
-  if(write(fd, "x", 1) > 0){
+  if (write(fd, "x", 1) > 0)
+  {
     printf(1, "write . succeeded!\n");
     exit();
   }
@@ -1340,20 +1545,22 @@ dirfile(void)
 }
 
 // test that iput() is called at the end of _namei()
-void
-iref(void)
+void iref(void)
 {
   int i, fd;
 
   printf(1, "empty file name\n");
 
   // the 50 is NINODE
-  for(i = 0; i < 50 + 1; i++){
-    if(mkdir("irefd") != 0){
+  for (i = 0; i < 50 + 1; i++)
+  {
+    if (mkdir("irefd") != 0)
+    {
       printf(1, "mkdir irefd failed\n");
       exit();
     }
-    if(chdir("irefd") != 0){
+    if (chdir("irefd") != 0)
+    {
       printf(1, "chdir irefd failed\n");
       exit();
     }
@@ -1361,10 +1568,10 @@ iref(void)
     mkdir("");
     link("README", "");
     fd = open("", O_CREATE);
-    if(fd >= 0)
+    if (fd >= 0)
       close(fd);
     fd = open("xx", O_CREATE);
-    if(fd >= 0)
+    if (fd >= 0)
       close(fd);
     unlink("xx");
   }
@@ -1376,34 +1583,38 @@ iref(void)
 // test that fork fails gracefully
 // the forktest binary also does this, but it runs out of proc entries first.
 // inside the bigger usertests binary, we run out of memory first.
-void
-forktest(void)
+void forktest(void)
 {
   int n, pid;
 
   printf(1, "fork test\n");
 
-  for(n=0; n<1000; n++){
+  for (n = 0; n < 1000; n++)
+  {
     pid = fork();
-    if(pid < 0)
+    if (pid < 0)
       break;
-    if(pid == 0)
+    if (pid == 0)
       exit();
   }
 
-  if(n == 1000){
+  if (n == 1000)
+  {
     printf(1, "fork claimed to work 1000 times!\n");
     exit();
   }
 
-  for(; n > 0; n--){
-    if(wait() < 0){
+  for (; n > 0; n--)
+  {
+    if (wait() < 0)
+    {
       printf(1, "wait stopped early\n");
       exit();
     }
   }
 
-  if(wait() != -1){
+  if (wait() != -1)
+  {
     printf(1, "wait got too many\n");
     exit();
   }
@@ -1411,8 +1622,7 @@ forktest(void)
   printf(1, "fork test OK\n");
 }
 
-void
-sbrktest(void)
+void sbrktest(void)
 {
   int fds[2], pid, pids[10], ppid;
   char *a, *b, *c, *lastaddr, *oldbrk, *p, scratch;
@@ -1424,9 +1634,11 @@ sbrktest(void)
   // can one sbrk() less than a page?
   a = sbrk(0);
   int i;
-  for(i = 0; i < 5000; i++){
+  for (i = 0; i < 5000; i++)
+  {
     b = sbrk(1);
-    if(b != a){
+    if (b != a)
+    {
       printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
       exit();
     }
@@ -1434,41 +1646,46 @@ sbrktest(void)
     a = b + 1;
   }
   pid = fork();
-  if(pid < 0){
+  if (pid < 0)
+  {
     printf(stdout, "sbrk test fork failed\n");
     exit();
   }
   c = sbrk(1);
   c = sbrk(1);
-  if(c != a + 1){
+  if (c != a + 1)
+  {
     printf(stdout, "sbrk test failed post-fork\n");
     exit();
   }
-  if(pid == 0)
+  if (pid == 0)
     exit();
   wait();
 
   // can one grow address space to something big?
-#define BIG (100*1024*1024)
+#define BIG (100 * 1024 * 1024)
   a = sbrk(0);
   amt = (BIG) - (uint)a;
   p = sbrk(amt);
-  if (p != a) {
+  if (p != a)
+  {
     printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
     exit();
   }
-  lastaddr = (char*) (BIG-1);
+  lastaddr = (char *)(BIG - 1);
   *lastaddr = 99;
 
   // can one de-allocate?
   a = sbrk(0);
   c = sbrk(-4096);
-  if(c == (char*)0xffffffff){
+  if (c == (char *)0xffffffff)
+  {
     printf(stdout, "sbrk could not deallocate\n");
     exit();
   }
   c = sbrk(0);
-  if(c != a - 4096){
+  if (c != a - 4096)
+  {
     printf(stdout, "sbrk deallocation produced wrong address, a %x c %x\n", a, c);
     exit();
   }
@@ -1476,11 +1693,13 @@ sbrktest(void)
   // can one re-allocate that page?
   a = sbrk(0);
   c = sbrk(4096);
-  if(c != a || sbrk(0) != a + 4096){
+  if (c != a || sbrk(0) != a + 4096)
+  {
     printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
     exit();
   }
-  if(*lastaddr == 99){
+  if (*lastaddr == 99)
+  {
     // should be zero
     printf(stdout, "sbrk de-allocation didn't really deallocate\n");
     exit();
@@ -1488,20 +1707,24 @@ sbrktest(void)
 
   a = sbrk(0);
   c = sbrk(-(sbrk(0) - oldbrk));
-  if(c != a){
+  if (c != a)
+  {
     printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
     exit();
   }
 
   // can we read the kernel's memory?
-  for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
+  for (a = (char *)(KERNBASE); a < (char *)(KERNBASE + 2000000); a += 50000)
+  {
     ppid = getpid();
     pid = fork();
-    if(pid < 0){
+    if (pid < 0)
+    {
       printf(stdout, "fork failed\n");
       exit();
     }
-    if(pid == 0){
+    if (pid == 0)
+    {
       printf(stdout, "oops could read %x = %x\n", a, *a);
       kill(ppid);
       exit();
@@ -1511,67 +1734,70 @@ sbrktest(void)
 
   // if we run the system out of memory, does it clean up the last
   // failed allocation?
-  if(pipe(fds) != 0){
+  if (pipe(fds) != 0)
+  {
     printf(1, "pipe() failed\n");
     exit();
   }
-  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
-    if((pids[i] = fork()) == 0){
+  for (i = 0; i < sizeof(pids) / sizeof(pids[0]); i++)
+  {
+    if ((pids[i] = fork()) == 0)
+    {
       // allocate a lot of memory
       sbrk(BIG - (uint)sbrk(0));
       write(fds[1], "x", 1);
       // sit around until killed
-      for(;;) sleep(1000);
+      for (;;)
+        sleep(1000);
     }
-    if(pids[i] != -1)
+    if (pids[i] != -1)
       read(fds[0], &scratch, 1);
   }
   // if those failed allocations freed up the pages they did allocate,
   // we'll be able to allocate here
   c = sbrk(4096);
-  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
-    if(pids[i] == -1)
+  for (i = 0; i < sizeof(pids) / sizeof(pids[0]); i++)
+  {
+    if (pids[i] == -1)
       continue;
     kill(pids[i]);
     wait();
   }
-  if(c == (char*)0xffffffff){
+  if (c == (char *)0xffffffff)
+  {
     printf(stdout, "failed sbrk leaked memory\n");
     exit();
   }
 
-  if(sbrk(0) > oldbrk)
+  if (sbrk(0) > oldbrk)
     sbrk(-(sbrk(0) - oldbrk));
 
   printf(stdout, "sbrk test OK\n");
 }
 
-void
-validateint(int *p)
+void validateint(int *p)
 {
   int res;
   asm("mov %%esp, %%ebx\n\t"
       "mov %3, %%esp\n\t"
       "int %2\n\t"
-      "mov %%ebx, %%esp" :
-      "=a" (res) :
-      "a" (SYS_sleep), "n" (T_SYSCALL), "c" (p) :
-      "ebx");
+      "mov %%ebx, %%esp" : "=a"(res) : "a"(SYS_sleep), "n"(T_SYSCALL), "c"(p) : "ebx");
 }
 
-void
-validatetest(void)
+void validatetest(void)
 {
   int hi, pid;
   uint p;
 
   printf(stdout, "validate test\n");
-  hi = 1100*1024;
+  hi = 1100 * 1024;
 
-  for(p = 0; p <= (uint)hi; p += 4096){
-    if((pid = fork()) == 0){
+  for (p = 0; p <= (uint)hi; p += 4096)
+  {
+    if ((pid = fork()) == 0)
+    {
       // try to crash the kernel by passing in a badly placed integer
-      validateint((int*)p);
+      validateint((int *)p);
       exit();
     }
     sleep(0);
@@ -1580,7 +1806,8 @@ validatetest(void)
     wait();
 
     // try to crash the kernel by passing in a bad string pointer
-    if(link("nosuchfile", (char*)p) != -1){
+    if (link("nosuchfile", (char *)p) != -1)
+    {
       printf(stdout, "link should not succeed\n");
       exit();
     }
@@ -1591,14 +1818,15 @@ validatetest(void)
 
 // does unintialized data start out zero?
 char uninit[10000];
-void
-bsstest(void)
+void bsstest(void)
 {
   int i;
 
   printf(stdout, "bss test\n");
-  for(i = 0; i < sizeof(uninit); i++){
-    if(uninit[i] != '\0'){
+  for (i = 0; i < sizeof(uninit); i++)
+  {
+    if (uninit[i] != '\0')
+    {
       printf(stdout, "bss test failed\n");
       exit();
     }
@@ -1609,32 +1837,35 @@ bsstest(void)
 // does exec return an error if the arguments
 // are larger than a page? or does it write
 // below the stack and wreck the instructions/data?
-void
-bigargtest(void)
+void bigargtest(void)
 {
   int pid, fd;
 
   unlink("bigarg-ok");
   pid = fork();
-  if(pid == 0){
+  if (pid == 0)
+  {
     static char *args[MAXARG];
     int i;
-    for(i = 0; i < MAXARG-1; i++)
+    for (i = 0; i < MAXARG - 1; i++)
       args[i] = "bigargs test: failed\n                                                                                                                                                                                                       ";
-    args[MAXARG-1] = 0;
+    args[MAXARG - 1] = 0;
     printf(stdout, "bigarg test\n");
     exec("echo", args);
     printf(stdout, "bigarg test ok\n");
     fd = open("bigarg-ok", O_CREATE);
     close(fd);
     exit();
-  } else if(pid < 0){
+  }
+  else if (pid < 0)
+  {
     printf(stdout, "bigargtest: fork failed\n");
     exit();
   }
   wait();
   fd = open("bigarg-ok", 0);
-  if(fd < 0){
+  if (fd < 0)
+  {
     printf(stdout, "bigarg test failed!\n");
     exit();
   }
@@ -1644,15 +1875,15 @@ bigargtest(void)
 
 // what happens when the file system runs out of blocks?
 // answer: balloc panics, so this test is not useful.
-void
-fsfull()
+void fsfull()
 {
   int nfiles;
   int fsblocks = 0;
 
   printf(1, "fsfull test\n");
 
-  for(nfiles = 0; ; nfiles++){
+  for (nfiles = 0;; nfiles++)
+  {
     char name[64];
     name[0] = 'f';
     name[1] = '0' + nfiles / 1000;
@@ -1661,26 +1892,29 @@ fsfull()
     name[4] = '0' + (nfiles % 10);
     name[5] = '\0';
     printf(1, "writing %s\n", name);
-    int fd = open(name, O_CREATE|O_RDWR);
-    if(fd < 0){
+    int fd = open(name, O_CREATE | O_RDWR);
+    if (fd < 0)
+    {
       printf(1, "open %s failed\n", name);
       break;
     }
     int total = 0;
-    while(1){
+    while (1)
+    {
       int cc = write(fd, buf, 512);
-      if(cc < 512)
+      if (cc < 512)
         break;
       total += cc;
       fsblocks++;
     }
     printf(1, "wrote %d bytes\n", total);
     close(fd);
-    if(total == 0)
+    if (total == 0)
       break;
   }
 
-  while(nfiles >= 0){
+  while (nfiles >= 0)
+  {
     char name[64];
     name[0] = 'f';
     name[1] = '0' + nfiles / 1000;
@@ -1695,11 +1929,10 @@ fsfull()
   printf(1, "fsfull test finished\n");
 }
 
-void
-uio()
+void uio()
 {
-  #define RTC_ADDR 0x70
-  #define RTC_DATA 0x71
+#define RTC_ADDR 0x70
+#define RTC_DATA 0x71
 
   ushort port = 0;
   uchar val = 0;
@@ -1707,17 +1940,20 @@ uio()
 
   printf(1, "uio test\n");
   pid = fork();
-  if(pid == 0){
+  if (pid == 0)
+  {
     port = RTC_ADDR;
-    val = 0x09;  /* year */
+    val = 0x09; /* year */
     /* http://wiki.osdev.org/Inline_Assembly/Examples */
-    asm volatile("outb %0,%1"::"a"(val), "d" (port));
+    asm volatile("outb %0,%1" ::"a"(val), "d"(port));
     port = RTC_DATA;
-    asm volatile("inb %1,%0" : "=a" (val) : "d" (port));
+    asm volatile("inb %1,%0" : "=a"(val) : "d"(port));
     printf(1, "uio: uio succeeded; test FAILED\n");
     exit();
-  } else if(pid < 0){
-    printf (1, "fork failed\n");
+  }
+  else if (pid < 0)
+  {
+    printf(1, "fork failed\n");
     exit();
   }
   wait();
@@ -1728,7 +1964,8 @@ void argptest()
 {
   int fd;
   fd = open("init", O_RDONLY);
-  if (fd < 0) {
+  if (fd < 0)
+  {
     printf(2, "open failed\n");
     exit();
   }
@@ -1745,12 +1982,13 @@ rand()
   return randstate;
 }
 
-int
-main(int argc, char *argv[])
+
+int main(int argc, char *argv[])
 {
   printf(1, "usertests starting\n");
 
-  if(open("usertests.ran", 0) >= 0){
+  if (open("usertests.ran", 0) >= 0)
+  {
     printf(1, "already ran user tests -- rebuild fs.img\n");
     exit();
   }
diff --git a/usys.S b/usys.S
index 8bfd8a1..1a4ebc3 100644
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,6 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(pstat)
+SYSCALL(nice)
+SYSCALL(getchosen)
\ No newline at end of file
